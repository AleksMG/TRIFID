<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Trifid Cipher Cracker</title>
    <style>
        :root {
            --primary: #007AFF;
            --primary-light: rgba(0, 122, 255, 0.1);
            --secondary: #34C759;
            --tertiary: #FF9500;
            --danger: #FF3B30;
            --background: #F2F2F7;
            --card: #FFFFFF;
            --text: #1C1C1E;
            --secondary-text: #8E8E93;
            --border: #D1D1D6;
            --highlight-plaintext: #FFD700;
            --highlight-trigram: rgba(52, 199, 89, 0.3);
            --highlight-quadgram: rgba(0, 122, 255, 0.3);
        }
        
        @media (prefers-color-scheme: dark) {
            :root {
                --primary: #0A84FF;
                --primary-light: rgba(10, 132, 255, 0.2);
                --secondary: #30D158;
                --tertiary: #FF9F0A;
                --danger: #FF453A;
                --background: #1C1C1E;
                --card: #2C2C2E;
                --text: #FFFFFF;
                --secondary-text: #8E8E93;
                --border: #38383A;
                --highlight-plaintext: #FFD700;
                --highlight-trigram: rgba(48, 209, 88, 0.3);
                --highlight-quadgram: rgba(10, 132, 255, 0.3);
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);
            color: var(--text);
            margin: 0;
            padding: 0;
            max-width: 100vw;
            min-height: 100vh;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
            padding: 16px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .card {
            background-color: var(--card);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        
        .card-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--primary);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--secondary-text);
            font-weight: 500;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background-color: var(--card);
            color: var(--text);
            font-size: 16px;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .primary-button {
            background-color: var(--primary);
            color: white;
        }
        
        .secondary-button {
            background-color: var(--border);
            color: var(--text);
        }
        
        .danger-button {
            background-color: var(--danger);
            color: white;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .progress-container {
            margin-top: 16px;
        }
        
        .progress-bar {
            height: 6px;
            background-color: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status-text {
            font-size: 14px;
            color: var(--secondary-text);
            margin-top: 8px;
            text-align: center;
        }
        
        .results-container {
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
            border-radius: 8px;
            background-color: var(--card);
        }
        
        .result-item.best {
            border-left: 4px solid var(--primary);
            background-color: var(--primary-light);
        }
        
        .result-key {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--primary);
        }
        
        .result-text {
            font-family: monospace;
            margin-bottom: 4px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }
        
        .result-score {
            font-size: 14px;
            color: var(--secondary-text);
            display: flex;
            justify-content: space-between;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .workers-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .workers-control input {
            flex: 1;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--primary);
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        .badge-secondary {
            background-color: var(--secondary);
        }
        
        .badge-tertiary {
            background-color: var(--tertiary);
        }
        
        .highlight-plaintext {
            background-color: var(--highlight-plaintext);
            font-weight: bold;
            padding: 0 2px;
            border-radius: 2px;
        }
        
        .highlight-trigram {
            background-color: var(--highlight-trigram);
            border-radius: 2px;
        }
        
        .highlight-quadgram {
            background-color: var(--highlight-quadgram);
            border-radius: 2px;
        }
        
        .cube-visualization {
            margin-top: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            background-color: var(--background);
            overflow-x: auto;
        }
        
        .cube-layer {
            margin-bottom: 12px;
        }
        
        .cube-layer-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--secondary-text);
        }
        
        .cube-row {
            display: flex;
            margin-bottom: 2px;
        }
        
        .cube-cell {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            margin-right: 2px;
            font-family: monospace;
            font-size: 14px;
        }
        
        .stats-container {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }
        
        .stat-item {
            flex: 1;
            text-align: center;
            padding: 8px;
            background-color: var(--background);
            border-radius: 8px;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 16px;
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--secondary-text);
        }
        
        .keyboard-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .keyboard-button {
            padding: 6px 12px;
            border-radius: 6px;
            background-color: var(--background);
            border: 1px solid var(--border);
            cursor: pointer;
            font-size: 14px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom: 2px solid var(--primary);
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .top-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-title">Configuration</div>
            
            <div class="form-group">
                <label for="ciphertext">Ciphertext</label>
                <textarea id="ciphertext" spellcheck="false">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
            </div>
            
            <div class="form-group">
                <label for="alphabet">Alphabet (27 chars for 3×3×3 cube)</label>
                <input id="alphabet" value="ABCDEFGHIKLMNOPQRSTUVWXYZ?*" placeholder="Enter custom alphabet" spellcheck="false">
            </div>
            
            <div class="settings-grid">
                <div class="form-group">
                    <label for="searchMode">Search Mode</label>
                    <select id="searchMode">
                        <option value="full">Full Key Search</option>
                        <option value="partial">Partial Key Search</option>
                        <option value="known">Known Plaintext</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="period">Trifid Period</label>
                    <input id="period" type="number" value="5" min="1" max="20">
                </div>
            </div>
            
            <div class="form-group">
                <label for="knownPlaintext">Known Plaintext (for verification)</label>
                <input id="knownPlaintext" placeholder="e.g., BERLIN" spellcheck="false">
            </div>
            
            <div class="form-group">
                <label for="keyLength">Key Length (for partial search)</label>
                <input id="keyLength" type="number" value="6" min="1" max="20">
            </div>
            
            <div class="form-group">
                <label>Worker Configuration</label>
                <div class="workers-control">
                    <input id="workerCount" type="number" value="4" min="1" max="16" placeholder="Worker count">
                    <span class="badge" id="workerStatus">Idle</span>
                </div>
            </div>
            
            <div class="button-group">
                <button id="startButton" class="primary-button">Start Cracking</button>
                <button id="stopButton" class="danger-button" disabled>Stop</button>
                <button id="pauseButton" class="secondary-button" disabled>Pause</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill"></div>
                </div>
                <div id="status" class="status-text">Ready</div>
            </div>
            
            <div class="stats-container">
                <div class="stat-item">
                    <div class="stat-value" id="keysTested">0</div>
                    <div class="stat-label">Keys Tested</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="keysPerSec">0</div>
                    <div class="stat-label">Keys/Sec</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalPossible">∞</div>
                    <div class="stat-label">Total Possible</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="timeRemaining">--</div>
                    <div class="stat-label">Est. Time</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="tabs">
                <div class="tab active" data-tab="results">Results <span id="resultsCount" class="badge">0</span></div>
                <div class="tab" data-tab="cube">Cube Visualization</div>
                <div class="tab" data-tab="stats">Statistics</div>
            </div>
            
            <div id="results" class="tab-content active">
                <div class="top-results-header">
                    <h3>Top 20 Results</h3>
                    <div class="badge" id="bestScore">Best: 0.00</div>
                </div>
                <div id="resultsContainer" class="results-container"></div>
            </div>
            
            <div id="cube" class="tab-content">
                <div class="cube-visualization" id="cubeVisualization">
                    <p>No cube generated yet. Start cracking to see the cube visualization.</p>
                </div>
            </div>
            
            <div id="stats" class="tab-content">
                <div id="statsContainer" class="results-container">
                    <p>Statistics will appear here after analysis.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const config = {
            workerPath: 'trifid-worker.js',
            maxWorkers: 16,
            resultsLimit: 20, // Only show top 20 results
            maxKeysPerWorker: 100000,
            updateInterval: 1000,
            maxResultsToKeep: 100
        };
        
        // State
        let state = {
            isRunning: false,
            isPaused: false,
            workers: [],
            activeWorkers: 0,
            bestScore: -Infinity,
            resultsCount: 0,
            startTime: null,
            keysTested: 0,
            totalPossibleKeys: Infinity,
            results: [],
            currentCube: null,
            currentKey: null,
            updateIntervalId: null,
            processedKeys: new Set(),
            workerKeyRanges: {}
        };
        
        // DOM Elements
        const elements = {
            ciphertext: document.getElementById('ciphertext'),
            alphabet: document.getElementById('alphabet'),
            searchMode: document.getElementById('searchMode'),
            knownPlaintext: document.getElementById('knownPlaintext'),
            keyLength: document.getElementById('keyLength'),
            period: document.getElementById('period'),
            workerCount: document.getElementById('workerCount'),
            workerStatus: document.getElementById('workerStatus'),
            startButton: document.getElementById('startButton'),
            stopButton: document.getElementById('stopButton'),
            pauseButton: document.getElementById('pauseButton'),
            progressBar: document.getElementById('progressBar'),
            status: document.getElementById('status'),
            resultsContainer: document.getElementById('resultsContainer'),
            cubeVisualization: document.getElementById('cubeVisualization'),
            statsContainer: document.getElementById('statsContainer'),
            resultsCount: document.getElementById('resultsCount'),
            keysTested: document.getElementById('keysTested'),
            keysPerSec: document.getElementById('keysPerSec'),
            totalPossible: document.getElementById('totalPossible'),
            timeRemaining: document.getElementById('timeRemaining'),
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            bestScore: document.getElementById('bestScore')
        };
        
        // Initialize
        function init() {
            elements.startButton.addEventListener('click', startCracking);
            elements.stopButton.addEventListener('click', stopCracking);
            elements.pauseButton.addEventListener('click', togglePause);
            
            // Tab switching
            elements.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Update worker count based on hardware
            updateOptimalWorkerCount();
            
            // Load saved settings if available
            loadSettings();
            
            // Update total possible keys when parameters change
            elements.alphabet.addEventListener('input', updateTotalPossibleKeys);
            elements.keyLength.addEventListener('input', updateTotalPossibleKeys);
            elements.searchMode.addEventListener('change', updateTotalPossibleKeys);
            
            // Initial calculation
            updateTotalPossibleKeys();
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            elements.tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            elements.tabContents.forEach(content => {
                if (content.id === tabName) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
            
            // Refresh cube visualization if needed
            if (tabName === 'cube' && state.currentCube) {
                renderCubeVisualization(state.currentCube);
            }
        }
        
        // Determine optimal worker count
        function updateOptimalWorkerCount() {
            const cores = navigator.hardwareConcurrency || 4;
            elements.workerCount.value = Math.min(cores, config.maxWorkers);
            updateWorkerStatus();
        }
        
        // Update worker status display
        function updateWorkerStatus() {
            elements.workerStatus.textContent = 
                state.isRunning ? 
                    `${state.activeWorkers} active${state.isPaused ? ' (paused)' : ''}` : 
                    'Idle';
        }
        
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                ciphertext: elements.ciphertext.value,
                alphabet: elements.alphabet.value,
                searchMode: elements.searchMode.value,
                knownPlaintext: elements.knownPlaintext.value,
                keyLength: elements.keyLength.value,
                period: elements.period.value,
                workerCount: elements.workerCount.value
            };
            
            localStorage.setItem('trifidCrackerSettings', JSON.stringify(settings));
        }
        
        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('trifidCrackerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    elements.ciphertext.value = settings.ciphertext || elements.ciphertext.value;
                    elements.alphabet.value = settings.alphabet || elements.alphabet.value;
                    elements.searchMode.value = settings.searchMode || elements.searchMode.value;
                    elements.knownPlaintext.value = settings.knownPlaintext || '';
                    elements.keyLength.value = settings.keyLength || elements.keyLength.value;
                    elements.period.value = settings.period || elements.period.value;
                    elements.workerCount.value = settings.workerCount || elements.workerCount.value;
                } catch (e) {
                    console.error('Failed to load settings', e);
                }
            }
        }
        
        // Calculate total possible keys based on current settings
        function updateTotalPossibleKeys() {
            const alphabet = elements.alphabet.value;
            const keyLength = parseInt(elements.keyLength.value);
            const searchMode = elements.searchMode.value;
            
            if (!alphabet || alphabet.length === 0) {
                elements.totalPossible.textContent = '∞';
                state.totalPossibleKeys = Infinity;
                return;
            }
            
            let total;
            
            if (searchMode === 'full') {
                // For full search, we're using random keys so we can't calculate total
                total = Infinity;
            } else if (searchMode === 'partial') {
                // Partial search: alphabet_size ^ key_length
                total = Math.pow(alphabet.length, keyLength);
            } else {
                // Known plaintext mode - hard to estimate
                total = Infinity;
            }
            
            state.totalPossibleKeys = total;
            
            if (total === Infinity) {
                elements.totalPossible.textContent = '∞';
            } else {
                elements.totalPossible.textContent = total.toLocaleString();
            }
        }
        
        // Start cracking process
        async function startCracking() {
            if (state.isRunning) return;
            
            // Validate inputs
            const ciphertext = elements.ciphertext.value.toUpperCase().replace(/[^A-Z?*]/g, '');
            const alphabet = elements.alphabet.value.toUpperCase().replace(/[^A-Z?*]/g, '');
            const searchMode = elements.searchMode.value;
            const knownPlaintext = elements.knownPlaintext.value.toUpperCase();
            const keyLength = parseInt(elements.keyLength.value);
            const period = parseInt(elements.period.value);
            const workerCount = parseInt(elements.workerCount.value);
            
            if (!ciphertext) {
                showError("Please enter ciphertext!");
                return;
            }
            
            const requiredChars = 27; // For 3×3×3 cube
            if (alphabet.length < requiredChars) {
                showError(`Alphabet needs at least ${requiredChars} characters for 3×3×3 cube!`);
                return;
            }
            
            // Save settings
            saveSettings();
            
            // Reset state
            state = {
                isRunning: true,
                isPaused: false,
                workers: [],
                activeWorkers: 0,
                bestScore: -Infinity,
                resultsCount: 0,
                startTime: performance.now(),
                keysTested: 0,
                totalPossibleKeys: state.totalPossibleKeys,
                results: [],
                currentCube: null,
                currentKey: null,
                updateIntervalId: null,
                processedKeys: new Set(),
                workerKeyRanges: {}
            };
            
            elements.resultsContainer.innerHTML = '';
            elements.statsContainer.innerHTML = '<p>Statistics will appear here after analysis.</p>';
            elements.resultsCount.textContent = '0';
            elements.keysTested.textContent = '0';
            elements.keysPerSec.textContent = '0';
            elements.timeRemaining.textContent = '--';
            elements.bestScore.textContent = 'Best: 0.00';
            elements.startButton.disabled = true;
            elements.stopButton.disabled = false;
            elements.pauseButton.disabled = false;
            elements.progressBar.style.width = '0%';
            elements.status.textContent = 'Initializing workers...';
            
            // Create workers
            try {
                for (let i = 0; i < workerCount; i++) {
                    const worker = new Worker(config.workerPath);
                    
                    worker.onmessage = function(e) {
                        handleWorkerMessage(worker, e.data);
                    };
                    
                    worker.onerror = function(error) {
                        console.error('Worker error:', error);
                        worker.terminate();
                        state.activeWorkers--;
                        updateWorkerStatus();
                        
                        if (state.activeWorkers === 0) {
                            stopCracking();
                        }
                    };
                    
                    state.workers.push(worker);
                }
                
                // Start workers
                state.activeWorkers = workerCount;
                updateWorkerStatus();
                
                // Calculate keys to test based on search mode
                let keysPerWorker;
                if (searchMode === 'full') {
                    keysPerWorker = Math.ceil(config.maxKeysPerWorker / workerCount);
                } else if (searchMode === 'partial') {
                    keysPerWorker = Math.ceil(Math.pow(alphabet.length, keyLength) / workerCount);
                    keysPerWorker = Math.min(keysPerWorker, config.maxKeysPerWorker);
                } else { // known plaintext
                    keysPerWorker = Math.ceil(config.maxKeysPerWorker / workerCount);
                }
                
                // Start periodic updates
                state.updateIntervalId = setInterval(updateStats, config.updateInterval);
                
                // Start workers with unique key ranges
                state.workers.forEach((worker, index) => {
                    const workerId = index;
                    const startIndex = index * keysPerWorker;
                    const endIndex = startIndex + keysPerWorker - 1;
                    
                    state.workerKeyRanges[workerId] = { start: startIndex, end: endIndex };
                    
                    worker.postMessage({
                        type: 'start',
                        ciphertext: ciphertext,
                        alphabet: alphabet,
                        searchMode: searchMode,
                        knownPlaintext: knownPlaintext,
                        keyLength: keyLength,
                        period: period,
                        workerId: workerId,
                        totalWorkers: workerCount,
                        keysToTest: keysPerWorker,
                        startIndex: startIndex
                    });
                });
                
                elements.status.textContent = `Running with ${workerCount} workers...`;
            } catch (error) {
                console.error('Failed to initialize workers:', error);
                showError('Failed to start workers. Please check console for details.');
                stopCracking();
            }
        }
        
        // Handle messages from workers
        function handleWorkerMessage(worker, data) {
            switch (data.type) {
                case 'progress':
                    state.keysTested += data.keysTested;
                    if (data.cube) {
                        state.currentCube = data.cube;
                        state.currentKey = data.key;
                    }
                    break;
                    
                case 'result':
                    state.resultsCount++;
                    
                    // Add to results if score is in top N
                    if (state.results.length < config.maxResultsToKeep || data.score > state.results[state.results.length-1].score) {
                        state.results.push(data);
                        // Keep results sorted by score descending
                        state.results.sort((a, b) => b.score - a.score);
                        // Trim to max results to keep
                        if (state.results.length > config.maxResultsToKeep) {
                            state.results.pop();
                        }
                        
                        // Update best score if needed
                        if (data.score > state.bestScore) {
                            state.bestScore = data.score;
                            elements.bestScore.textContent = `Best: ${data.score.toFixed(2)}`;
                        }
                        
                        // Update UI
                        updateResultsDisplay();
                    }
                    break;
                    
                case 'complete':
                    worker.terminate();
                    state.activeWorkers--;
                    updateWorkerStatus();
                    
                    if (state.activeWorkers === 0) {
                        stopCracking();
                        const elapsed = ((performance.now() - state.startTime) / 1000).toFixed(2);
                        elements.status.textContent = `Search completed in ${elapsed}s (${state.keysTested.toLocaleString()} keys tested)`;
                    }
                    break;
            }
        }
        
        // Update results display with top 20 results
        function updateResultsDisplay() {
            elements.resultsCount.textContent = state.resultsCount.toLocaleString();
            
            // Clear and rebuild results
            elements.resultsContainer.innerHTML = '';
            
            // Show top 20 results
            const topResults = state.results.slice(0, config.resultsLimit);
            topResults.forEach(result => {
                addResult(result, result.score === state.bestScore);
            });
        }
        
        // Update statistics display
        function updateStats() {
            if (!state.isRunning || state.isPaused) return;
            
            const elapsed = (performance.now() - state.startTime) / 1000;
            const keysPerSec = elapsed > 0 ? (state.keysTested / elapsed).toFixed(0) : 0;
            
            elements.keysTested.textContent = state.keysTested.toLocaleString();
            elements.keysPerSec.textContent = keysPerSec.toLocaleString();
            
            // Calculate estimated time remaining if we know total possible keys
            if (state.totalPossibleKeys !== Infinity && keysPerSec > 0) {
                const remainingKeys = state.totalPossibleKeys - state.keysTested;
                const remainingTime = remainingKeys / keysPerSec;
                
                if (remainingTime > 0) {
                    elements.timeRemaining.textContent = formatTime(remainingTime);
                }
            }
            
            // Update progress bar if we have an estimate
            if (state.totalPossibleKeys !== Infinity && state.totalPossibleKeys > 0) {
                const progress = Math.min(100, (state.keysTested / state.totalPossibleKeys) * 100);
                elements.progressBar.style.width = `${progress}%`;
            }
        }
        
        // Format time in HH:MM:SS
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            
            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':');
        }
        
        // Add result to the UI
        function addResult(data, isBest) {
            const resultItem = document.createElement('div');
            resultItem.className = `result-item ${isBest ? 'best' : ''}`;
            
            // Highlight known plaintext if provided
            let displayText = data.text;
            const knownPlaintext = elements.knownPlaintext.value.toUpperCase();
            
            if (knownPlaintext && knownPlaintext.length > 0) {
                const index = displayText.toUpperCase().indexOf(knownPlaintext);
                if (index >= 0) {
                    const before = displayText.substring(0, index);
                    const match = displayText.substring(index, index + knownPlaintext.length);
                    const after = displayText.substring(index + knownPlaintext.length);
                    displayText = `${before}<span class="highlight-plaintext">${match}</span>${after}`;
                }
            }
            
            // Highlight trigrams and quadgrams
            displayText = highlightPatterns(displayText);
            
            // Add cube visualization button
            const cubeButton = document.createElement('button');
            cubeButton.className = 'keyboard-button';
            cubeButton.textContent = 'Show Cube';
            cubeButton.onclick = () => {
                if (data.cube) {
                    state.currentCube = data.cube;
                    state.currentKey = data.key;
                    renderCubeVisualization(data.cube);
                    switchTab('cube');
                }
            };
            
            resultItem.innerHTML = `
                <div class="result-key">Key: ${data.key}</div>
                <div class="result-text">${displayText}</div>
                <div class="result-score">
                    <span>Score: ${data.score.toFixed(4)}</span>
                    <span>Trigrams: ${data.trigrams || 0}</span>
                    <span>Quadgrams: ${data.quadgrams || 0}</span>
                </div>
            `;
            
            resultItem.querySelector('.result-score').appendChild(cubeButton);
            elements.resultsContainer.appendChild(resultItem);
        }
        
        // Highlight trigrams and quadgrams in text
        function highlightPatterns(text) {
            // Common English trigrams
            const commonTrigrams = [
                'THE', 'AND', 'ING', 'ENT', 'ION', 'HER', 'FOR', 'THA', 'NTH', 'INT',
                'ERE', 'TIO', 'TER', 'EST', 'ERS', 'ATI', 'HAT', 'ATE', 'ALL', 'ETH'
            ];
            
            // Common English quadgrams
            const commonQuadgrams = [
                'TION', 'NTHE', 'THER', 'THAT', 'OFTHE', 'INGT', 'THEM', 'THEI', 
                'DTHE', 'ATIO', 'ETHE', 'THIS', 'TING', 'WITH', 'STHE', 'HERE'
            ];
            
            let highlighted = text;
            
            // Highlight quadgrams first (longer matches take precedence)
            for (const quadgram of commonQuadgrams) {
                const regex = new RegExp(quadgram, 'gi');
                highlighted = highlighted.replace(regex, 
                    match => `<span class="highlight-quadgram">${match}</span>`);
            }
            
            // Then highlight trigrams (but don't overlap with quadgrams)
            for (const trigram of commonTrigrams) {
                const regex = new RegExp(`(?<!")${trigram}(?!")`, 'gi');
                highlighted = highlighted.replace(regex, 
                    match => `<span class="highlight-trigram">${match}</span>`);
            }
            
            return highlighted;
        }
        
        // Render cube visualization
        function renderCubeVisualization(cube) {
            if (!cube || !cube.length) return;
            
            let html = `<h3>Cube for key: ${state.currentKey || 'None'}</h3>`;
            
            for (let layer = 0; layer < cube.length; layer++) {
                html += `<div class="cube-layer">
                    <div class="cube-layer-title">Layer ${layer + 1}</div>`;
                
                for (let row = 0; row < cube[layer].length; row++) {
                    html += '<div class="cube-row">';
                    
                    for (let col = 0; col < cube[layer][row].length; col++) {
                        const char = cube[layer][row][col];
                        html += `<div class="cube-cell">${char}</div>`;
                    }
                    
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            elements.cubeVisualization.innerHTML = html;
        }
        
        // Toggle pause state
        function togglePause() {
            if (!state.isRunning) return;
            
            state.isPaused = !state.isPaused;
            
            if (state.isPaused) {
                elements.pauseButton.textContent = 'Resume';
                elements.status.textContent = 'Paused';
                state.workers.forEach(worker => worker.postMessage({ type: 'pause' }));
            } else {
                elements.pauseButton.textContent = 'Pause';
                elements.status.textContent = 'Resuming...';
                state.workers.forEach(worker => worker.postMessage({ type: 'resume' }));
            }
        }
        
        // Stop cracking process
        function stopCracking() {
            if (!state.isRunning) return;
            
            state.isRunning = false;
            state.workers.forEach(worker => worker.terminate());
            state.workers = [];
            state.activeWorkers = 0;
            
            if (state.updateIntervalId) {
                clearInterval(state.updateIntervalId);
                state.updateIntervalId = null;
            }
            
            updateWorkerStatus();
            
            elements.startButton.disabled = false;
            elements.stopButton.disabled = true;
            elements.pauseButton.disabled = true;
            elements.pauseButton.textContent = 'Pause';
            
            // Generate statistics
            generateStatistics();
        }
        
        // Generate statistics from results
        function generateStatistics() {
            if (state.results.length === 0) return;
            
            let html = '<h3>Analysis Results</h3>';
            
            // Count of results with known plaintext
            const knownPlaintext = elements.knownPlaintext.value.toUpperCase();
            if (knownPlaintext && knownPlaintext.length > 0) {
                const matches = state.results.filter(r => 
                    r.text.toUpperCase().includes(knownPlaintext)).length;
                html += `<p>Found ${matches} results containing "${knownPlaintext}"</p>`;
            }
            
            // Best score
            const bestResult = state.results[0];
            
            html += `<div class="result-item best">
                <div class="result-key">Best Result: ${bestResult.key}</div>
                <div class="result-text">${highlightPatterns(bestResult.text)}</div>
                <div class="result-score">
                    <span>Score: ${bestResult.score.toFixed(4)}</span>
                    <span>Trigrams: ${bestResult.trigrams || 0}</span>
                    <span>Quadgrams: ${bestResult.quadgrams || 0}</span>
                </div>
            </div>`;
            
            // Common trigrams and quadgrams in best results
            const topResults = state.results.slice(0, 10);
            
            const trigramCounts = {};
            const quadgramCounts = {};
            
            topResults.forEach(result => {
                const text = result.text.toUpperCase();
                
                // Count trigrams
                for (let i = 0; i < text.length - 2; i++) {
                    const trigram = text.substr(i, 3);
                    trigramCounts[trigram] = (trigramCounts[trigram] || 0) + 1;
                }
                
                // Count quadgrams
                for (let i = 0; i < text.length - 3; i++) {
                    const quadgram = text.substr(i, 4);
                    quadgramCounts[quadgram] = (quadgramCounts[quadgram] || 0) + 1;
                }
            });
            
            // Sort and get top trigrams/quadgrams
            const topTrigrams = Object.entries(trigramCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const topQuadgrams = Object.entries(quadgramCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            html += `<h4>Most Common Trigrams in Top Results</h4><ul>`;
            topTrigrams.forEach(([trigram, count]) => {
                html += `<li>${trigram}: ${count} occurrences</li>`;
            });
            html += `</ul>`;
            
            html += `<h4>Most Common Quadgrams in Top Results</h4><ul>`;
            topQuadgrams.forEach(([quadgram, count]) => {
                html += `<li>${quadgram}: ${count} occurrences</li>`;
            });
            html += `</ul>`;
            
            elements.statsContainer.innerHTML = html;
        }
        
        // Show error message
        function showError(message) {
            elements.status.textContent = message;
            elements.status.style.color = 'var(--danger)';
            
            setTimeout(() => {
                elements.status.style.color = '';
                elements.status.textContent = 'Ready';
            }, 3000);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>

    <script>
        // Worker implementation will be in a separate file
        const workerBlob = new Blob([`
        // English language statistics for scoring
        const ENGLISH_FREQUENCY = {
            'A': 0.08167, 'B': 0.01492, 'C': 0.02782, 'D': 0.04253, 'E': 0.12702,
            'F': 0.02228, 'G': 0.02015, 'H': 0.06094, 'I': 0.06966, 'J': 0.00153,
            'K': 0.00772, 'L': 0.04025, 'M': 0.02406, 'N': 0.06749, 'O': 0.07507,
            'P': 0.01929, 'Q': 0.00095, 'R': 0.05987, 'S': 0.06327, 'T': 0.09056,
            'U': 0.02758, 'V': 0.00978, 'W': 0.02360, 'X': 0.00150, 'Y': 0.01974,
            'Z': 0.00074
        };

        const ENGLISH_TRIGRAMS = {
            "THE": 0.0181, "AND": 0.0073, "ING": 0.0072, "ENT": 0.0042, "ION": 0.0042,
            "HER": 0.0036, "FOR": 0.0034, "THA": 0.0033, "NTH": 0.0033, "INT": 0.0032,
            "ERE": 0.0031, "TIO": 0.0031, "TER": 0.0030, "EST": 0.0028, "ERS": 0.0028,
            "ATI": 0.0026, "HAT": 0.0026, "ATE": 0.0025, "ALL": 0.0025, "ETH": 0.0024,
            "HIS": 0.0024, "VER": 0.0024, "ITH": 0.0023, "STH": 0.0023, "OTH": 0.0022
        };

        const ENGLISH_QUADGRAMS = {
            "TION": 0.0015, "NTHE": 0.0014, "THER": 0.0013, "THAT": 0.0012, 
            "OFTHE": 0.0011, "INGT": 0.0010, "THEM": 0.0009, "THEI": 0.0009,
            "DTHE": 0.0009, "ATIO": 0.0009, "ETHE": 0.0008, "THIS": 0.0008,
            "TING": 0.0008, "WITH": 0.0008, "STHE": 0.0008, "HERE": 0.0007
        };

        // Score text based on letter, trigram and quadgram frequency
        function scoreText(text) {
            // Letter frequency score
            let letterScore = 0;
            const letterCounts = {};
            let totalLetters = 0;
            
            for (const char of text.toUpperCase()) {
                if (ENGLISH_FREQUENCY[char]) {
                    letterCounts[char] = (letterCounts[char] || 0) + 1;
                    totalLetters++;
                }
            }
            
            // Calculate chi-squared statistic
            for (const char in ENGLISH_FREQUENCY) {
                const expected = ENGLISH_FREQUENCY[char] * totalLetters;
                const observed = letterCounts[char] || 0;
                const difference = observed - expected;
                letterScore += (difference * difference) / expected;
            }
            
            // Invert so higher is better
            letterScore = 1 / (1 + letterScore);
            
            // Trigram score
            let trigramScore = 0;
            let trigramCount = 0;
            text = text.toUpperCase();
            for (let i = 0; i < text.length - 2; i++) {
                const trigram = text.substr(i, 3);
                if (ENGLISH_TRIGRAMS[trigram]) {
                    trigramScore += ENGLISH_TRIGRAMS[trigram];
                    trigramCount++;
                }
            }
            
            // Quadgram score
            let quadgramScore = 0;
            let quadgramCount = 0;
            for (let i = 0; i < text.length - 3; i++) {
                const quadgram = text.substr(i, 4);
                if (ENGLISH_QUADGRAMS[quadgram]) {
                    quadgramScore += ENGLISH_QUADGRAMS[quadgram];
                    quadgramCount++;
                }
            }
            
            // Normalize scores by text length
            trigramScore = trigramScore / (text.length / 3);
            quadgramScore = quadgramScore / (text.length / 4);
            
            // Combined score (weighted)
            return {
                score: (letterScore * 0.2 + trigramScore * 0.5 + quadgramScore * 0.3) * 100,
                trigrams: trigramCount,
                quadgrams: quadgramCount
            };
        }

        // Generate Trifid cube with key-based permutation (3×3×3 only)
        function generateCube(alphabet, key = '') {
            const cube = [[[], [], []], [[], [], []], [[], [], []]];
            
            // Create keyed alphabet
            let keyedAlphabet = '';
            const usedChars = new Set();
            
            // Add key characters first (without duplicates)
            for (const char of key.toUpperCase()) {
                if (!usedChars.has(char) && alphabet.includes(char)) {
                    keyedAlphabet += char;
                    usedChars.add(char);
                }
            }
            
            // Add remaining alphabet characters
            for (const char of alphabet) {
                if (!usedChars.has(char)) {
                    keyedAlphabet += char;
                }
            }
            
            // Fill the cube (3 layers, 3 rows, 3 columns)
            for (let layer = 0; layer < 3; layer++) {
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const index = layer * 9 + row * 3 + col;
                        cube[layer][row][col] = keyedAlphabet[index % keyedAlphabet.length];
                    }
                }
            }
            
            return cube;
        }

        // Generate random key of specified length
        function generateRandomKey(length, alphabet) {
            let key = '';
            for (let i = 0; i < length; i++) {
                key += alphabet[Math.floor(Math.random() * alphabet.length)];
            }
            return key;
        }

        // Generate sequential key for exhaustive search
        function generateSequentialKey(index, alphabet, keyLength) {
            let key = '';
            for (let i = 0; i < keyLength; i++) {
                key += alphabet[index % alphabet.length];
                index = Math.floor(index / alphabet.length);
            }
            return key;
        }

        // Full Trifid decryption with key
        function decryptTrifid(ciphertext, cube, key, period = 5) {
            const coords = {};
            
            // Build coordinate map
            for (let l = 0; l < 3; l++) {
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        coords[cube[l][r][c]] = [l, r, c];
                    }
                }
            }
            
            let decrypted = '';
            const groupSize = period;
            let allLayers = [];
            let allRows = [];
            let allCols = [];
            
            // Process ciphertext in groups
            for (let i = 0; i < ciphertext.length; i += groupSize) {
                const group = ciphertext.substr(i, groupSize);
                if (group.length === 0) break;
                
                // Extract coordinates for each character in group
                for (const char of group) {
                    const coord = coords[char];
                    if (coord) {
                        allLayers.push(coord[0]);
                        allRows.push(coord[1]);
                        allCols.push(coord[2]);
                    } else {
                        // Handle missing characters (use first layer as default)
                        allLayers.push(0);
                        allRows.push(0);
                        allCols.push(0);
                    }
                }
            }
            
            // Combine all coordinates
            const allCoords = allLayers.concat(allRows).concat(allCols);
            
            // Reconstruct plaintext from coordinates
            for (let i = 0; i < allCoords.length; i += 3) {
                if (i + 2 >= allCoords.length) break;
                const l = allCoords[i];
                const r = allCoords[i+1];
                const c = allCoords[i+2];
                decrypted += cube[l][r][c];
            }
            
            return decrypted;
        }

        // Main worker function
        self.onmessage = function(e) {
            const { 
                type, 
                ciphertext, 
                alphabet, 
                searchMode, 
                knownPlaintext, 
                keyLength,
                period,
                workerId,
                keysToTest,
                startIndex
            } = e.data;
            
            if (type === 'pause') {
                // Pause processing (we'll just wait for resume)
                self.paused = true;
                return;
            }
            
            if (type === 'resume') {
                // Resume processing
                self.paused = false;
                return;
            }
            
            if (type !== 'start') return;
            
            let bestScore = -Infinity;
            let keysTested = 0;
            const startTime = performance.now();
            let lastUpdateTime = startTime;
            
            // Main cracking loop
            for (let i = 0; i < keysToTest; i++) {
                // Check for pause messages
                if (self.paused) {
                    while (self.paused) {
                        // Wait for resume message
                        Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, 100);
                    }
                }
                
                // Generate test key based on search mode
                let testKey;
                if (searchMode === 'full') {
                    testKey = generateRandomKey(keyLength, alphabet);
                } else {
                    // For partial or known plaintext, use sequential keys from our assigned range
                    testKey = generateSequentialKey(startIndex + i, alphabet, keyLength);
                }
                
                // Generate cube with key permutation
                const cube = generateCube(alphabet, testKey);
                
                // Decrypt with current key
                const decrypted = decryptTrifid(ciphertext, cube, testKey, period);
                const scoreData = scoreText(decrypted);
                const score = scoreData.score;
                
                // Check for known plaintext if provided
                let valid = true;
                if (knownPlaintext && knownPlaintext.length > 0) {
                    valid = decrypted.toUpperCase().includes(knownPlaintext);
                }
                
                // Send progress update periodically
                keysTested++;
                const now = performance.now();
                if (now - lastUpdateTime > 1000 || i === keysToTest - 1) {
                    self.postMessage({
                        type: 'progress',
                        keysTested: keysTested,
                        cube: cube,
                        key: testKey
                    });
                    lastUpdateTime = now;
                }
                
                // Send result if it's good
                if (valid && score > bestScore * 0.9) { // Send anything close to best
                    if (score > bestScore) {
                        bestScore = score;
                    }
                    
                    self.postMessage({
                        type: 'result',
                        key: testKey,
                        text: decrypted,
                        score: score,
                        trigrams: scoreData.trigrams,
                        quadgrams: scoreData.quadgrams,
                        cube: cube
                    });
                }
            }
            
            self.postMessage({ 
                type: 'complete',
                keysTested: keysTested
            });
        };
        `], { type: 'application/javascript' });
        
        // Create worker URL
        const workerUrl = URL.createObjectURL(workerBlob);
        
        // Override the worker path in config
        config.workerPath = workerUrl;
    </script>
</body>
</html>
