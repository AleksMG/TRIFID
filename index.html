<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Trifid Cipher Cracker</title>
    <style>
        :root {
            --primary: #007AFF;
            --background: #F2F2F7;
            --card: #FFFFFF;
            --text: #1C1C1E;
            --secondary-text: #8E8E93;
            --border: #D1D1D6;
        }
        
        @media (prefers-color-scheme: dark) {
            :root {
                --primary: #0A84FF;
                --background: #1C1C1E;
                --card: #2C2C2E;
                --text: #FFFFFF;
                --secondary-text: #8E8E93;
                --border: #38383A;
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);
            color: var(--text);
            margin: 0;
            padding: 0;
            max-width: 100vw;
            min-height: 100vh;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
            padding: 16px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .card {
            background-color: var(--card);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        
        .card-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--primary);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--secondary-text);
            font-weight: 500;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background-color: var(--card);
            color: var(--text);
            font-size: 16px;
            box-sizing: border-box;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: none;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .primary-button {
            background-color: var(--primary);
            color: white;
        }
        
        .secondary-button {
            background-color: var(--border);
            color: var(--text);
        }
        
        .danger-button {
            background-color: #FF3B30;
            color: white;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .progress-container {
            margin-top: 16px;
        }
        
        .progress-bar {
            height: 6px;
            background-color: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status-text {
            font-size: 14px;
            color: var(--secondary-text);
            margin-top: 8px;
            text-align: center;
        }
        
        .results-container {
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
            border-radius: 8px;
            background-color: var(--card);
        }
        
        .result-item.best {
            border-left: 4px solid var(--primary);
            background-color: rgba(0, 122, 255, 0.1);
        }
        
        .result-key {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--primary);
        }
        
        .result-text {
            font-family: monospace;
            margin-bottom: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .result-score {
            font-size: 14px;
            color: var(--secondary-text);
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .workers-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .workers-control input {
            flex: 1;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--primary);
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-title">Configuration</div>
            
            <div class="form-group">
                <label for="ciphertext">Ciphertext</label>
                <textarea id="ciphertext">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
            </div>
            
            <div class="form-group">
                <label for="alphabet">Alphabet (27 chars for 3×3×3 cube)</label>
                <input id="alphabet" value="ABCDEFGHIKLMNOPQRSTUVWXYZ?*" placeholder="Enter custom alphabet">
            </div>
            
            <div class="settings-grid">
                <div class="form-group">
                    <label for="cubeSize">Cube Size</label>
                    <select id="cubeSize">
                        <option value="3">3×3×3 (27 chars)</option>
                        <option value="4">4×4×4 (64 chars)</option>
                        <option value="5">5×5×5 (125 chars)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="searchMode">Search Mode</label>
                    <select id="searchMode">
                        <option value="full">Full Key Search</option>
                        <option value="partial">Partial Key Search</option>
                        <option value="known">Known Plaintext</option>
                    </select>
                </div>
            </div>
            
            <div class="form-group">
                <label for="knownPlaintext">Known Plaintext (for verification)</label>
                <input id="knownPlaintext" placeholder="e.g., BERLIN">
            </div>
            
            <div class="form-group">
                <label for="keyLength">Key Length (for partial search)</label>
                <input id="keyLength" type="number" value="6" min="1" max="20">
            </div>
            
            <div class="form-group">
                <label>Worker Configuration</label>
                <div class="workers-control">
                    <input id="workerCount" type="number" value="4" min="1" max="16" placeholder="Worker count">
                    <span class="badge" id="workerStatus">Idle</span>
                </div>
            </div>
            
            <div class="button-group">
                <button id="startButton" class="primary-button">Start Cracking</button>
                <button id="stopButton" class="danger-button" disabled>Stop</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill"></div>
                </div>
                <div id="status" class="status-text">Ready</div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-title">Results <span id="resultsCount" class="badge">0</span></div>
            <div id="results" class="results-container"></div>
        </div>
    </div>

    <script>
        // Configuration
        const config = {
            workerPath: 'trifid-worker.js',
            maxWorkers: 16,
            resultsLimit: 1000,
            maxKeysPerWorker: 100000
        };
        
        // State
        let state = {
            isRunning: false,
            workers: [],
            activeWorkers: 0,
            bestScore: -Infinity,
            resultsCount: 0,
            startTime: null,
            keysTested: 0
        };
        
        // DOM Elements
        const elements = {
            ciphertext: document.getElementById('ciphertext'),
            alphabet: document.getElementById('alphabet'),
            cubeSize: document.getElementById('cubeSize'),
            searchMode: document.getElementById('searchMode'),
            knownPlaintext: document.getElementById('knownPlaintext'),
            keyLength: document.getElementById('keyLength'),
            workerCount: document.getElementById('workerCount'),
            workerStatus: document.getElementById('workerStatus'),
            startButton: document.getElementById('startButton'),
            stopButton: document.getElementById('stopButton'),
            progressBar: document.getElementById('progressBar'),
            status: document.getElementById('status'),
            results: document.getElementById('results'),
            resultsCount: document.getElementById('resultsCount')
        };
        
        // Initialize
        function init() {
            elements.startButton.addEventListener('click', startCracking);
            elements.stopButton.addEventListener('click', stopCracking);
            
            // Update worker count based on hardware
            updateOptimalWorkerCount();
            
            // Load saved settings if available
            loadSettings();
        }
        
        // Determine optimal worker count
        function updateOptimalWorkerCount() {
            const cores = navigator.hardwareConcurrency || 4;
            elements.workerCount.value = Math.min(cores, config.maxWorkers);
            updateWorkerStatus();
        }
        
        // Update worker status display
        function updateWorkerStatus() {
            elements.workerStatus.textContent = 
                state.isRunning ? `${state.activeWorkers} active` : 'Idle';
        }
        
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                ciphertext: elements.ciphertext.value,
                alphabet: elements.alphabet.value,
                cubeSize: elements.cubeSize.value,
                searchMode: elements.searchMode.value,
                knownPlaintext: elements.knownPlaintext.value,
                keyLength: elements.keyLength.value,
                workerCount: elements.workerCount.value
            };
            
            localStorage.setItem('trifidCrackerSettings', JSON.stringify(settings));
        }
        
        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem('trifidCrackerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    elements.ciphertext.value = settings.ciphertext || elements.ciphertext.value;
                    elements.alphabet.value = settings.alphabet || elements.alphabet.value;
                    elements.cubeSize.value = settings.cubeSize || elements.cubeSize.value;
                    elements.searchMode.value = settings.searchMode || elements.searchMode.value;
                    elements.knownPlaintext.value = settings.knownPlaintext || '';
                    elements.keyLength.value = settings.keyLength || elements.keyLength.value;
                    elements.workerCount.value = settings.workerCount || elements.workerCount.value;
                } catch (e) {
                    console.error('Failed to load settings', e);
                }
            }
        }
        
        // Start cracking process
        async function startCracking() {
            if (state.isRunning) return;
            
            // Validate inputs
            const ciphertext = elements.ciphertext.value.toUpperCase().replace(/[^A-Z?*]/g, '');
            const alphabet = elements.alphabet.value.toUpperCase().replace(/[^A-Z?*]/g, '');
            const cubeSize = parseInt(elements.cubeSize.value);
            const searchMode = elements.searchMode.value;
            const knownPlaintext = elements.knownPlaintext.value.toUpperCase();
            const keyLength = parseInt(elements.keyLength.value);
            const workerCount = parseInt(elements.workerCount.value);
            
            if (!ciphertext) {
                showError("Please enter ciphertext!");
                return;
            }
            
            const requiredChars = Math.pow(cubeSize, 3);
            if (alphabet.length < requiredChars) {
                showError(`Alphabet needs at least ${requiredChars} characters for ${cubeSize}×${cubeSize}×${cubeSize} cube!`);
                return;
            }
            
            // Save settings
            saveSettings();
            
            // Reset state
            state = {
                isRunning: true,
                workers: [],
                activeWorkers: 0,
                bestScore: -Infinity,
                resultsCount: 0,
                startTime: performance.now(),
                keysTested: 0
            };
            
            elements.results.innerHTML = '';
            elements.resultsCount.textContent = '0';
            elements.startButton.disabled = true;
            elements.stopButton.disabled = false;
            elements.progressBar.style.width = '0%';
            elements.status.textContent = 'Initializing workers...';
            
            // Create workers
            try {
                for (let i = 0; i < workerCount; i++) {
                    const worker = new Worker(config.workerPath);
                    
                    worker.onmessage = function(e) {
                        handleWorkerMessage(worker, e.data);
                    };
                    
                    worker.onerror = function(error) {
                        console.error('Worker error:', error);
                        worker.terminate();
                        state.activeWorkers--;
                        updateWorkerStatus();
                        
                        if (state.activeWorkers === 0) {
                            stopCracking();
                        }
                    };
                    
                    state.workers.push(worker);
                }
                
                // Start workers
                state.activeWorkers = workerCount;
                updateWorkerStatus();
                
                // Calculate keys to test based on search mode
                let keysPerWorker;
                if (searchMode === 'full') {
                    keysPerWorker = Math.ceil(config.maxKeysPerWorker / workerCount);
                } else if (searchMode === 'partial') {
                    keysPerWorker = Math.ceil(Math.pow(alphabet.length, keyLength) / workerCount);
                    keysPerWorker = Math.min(keysPerWorker, config.maxKeysPerWorker);
                } else { // known plaintext
                    keysPerWorker = Math.ceil(config.maxKeysPerWorker / workerCount);
                }
                
                state.workers.forEach((worker, index) => {
                    worker.postMessage({
                        type: 'start',
                        ciphertext: ciphertext,
                        alphabet: alphabet,
                        cubeSize: cubeSize,
                        searchMode: searchMode,
                        knownPlaintext: knownPlaintext,
                        keyLength: keyLength,
                        workerId: index,
                        totalWorkers: workerCount,
                        keysToTest: keysPerWorker
                    });
                });
                
                elements.status.textContent = `Running with ${workerCount} workers...`;
            } catch (error) {
                console.error('Failed to initialize workers:', error);
                showError('Failed to start workers. Please check console for details.');
                stopCracking();
            }
        }
        
        // Handle messages from workers
        function handleWorkerMessage(worker, data) {
            switch (data.type) {
                case 'progress':
                    state.keysTested += data.keysTested;
                    updateProgress();
                    break;
                    
                case 'result':
                    state.resultsCount++;
                    elements.resultsCount.textContent = state.resultsCount.toLocaleString();
                    
                    if (data.score > state.bestScore) {
                        state.bestScore = data.score;
                        addResult(data, true);
                    } else if (state.resultsCount % 10 === 0) {
                        // Only show some results to avoid flooding
                        addResult(data, false);
                    }
                    break;
                    
                case 'complete':
                    worker.terminate();
                    state.activeWorkers--;
                    updateWorkerStatus();
                    
                    if (state.activeWorkers === 0) {
                        stopCracking();
                        const elapsed = ((performance.now() - state.startTime) / 1000).toFixed(2);
                        elements.status.textContent = `Search completed in ${elapsed}s (${state.keysTested.toLocaleString()} keys tested)`;
                    }
                    break;
            }
        }
        
        // Update progress display
        function updateProgress() {
            const elapsed = (performance.now() - state.startTime) / 1000;
            const keysPerSec = (state.keysTested / elapsed).toFixed(0);
            
            elements.status.textContent = 
                `Testing keys... (${state.keysTested.toLocaleString()} keys, ${keysPerSec} keys/s)`;
            
            // Update progress bar if we have an estimate
            if (state.workers[0] && state.workers[0].keysToTest) {
                const totalKeys = state.workers[0].keysToTest * state.workers.length;
                const progress = Math.min(100, (state.keysTested / totalKeys) * 100);
                elements.progressBar.style.width = `${progress}%`;
            }
        }
        
        // Add result to the UI
        function addResult(data, isBest) {
            const resultItem = document.createElement('div');
            resultItem.className = `result-item ${isBest ? 'best' : ''}`;
            
            resultItem.innerHTML = `
                <div class="result-key">Key: ${data.key}</div>
                <div class="result-text">${data.text}</div>
                <div class="result-score">Score: ${data.score.toFixed(4)}</div>
            `;
            
            elements.results.insertBefore(resultItem, elements.results.firstChild);
            
            // Limit number of displayed results
            if (elements.results.children.length > config.resultsLimit) {
                elements.results.removeChild(elements.results.lastChild);
            }
        }
        
        // Stop cracking process
        function stopCracking() {
            if (!state.isRunning) return;
            
            state.isRunning = false;
            state.workers.forEach(worker => worker.terminate());
            state.workers = [];
            state.activeWorkers = 0;
            updateWorkerStatus();
            
            elements.startButton.disabled = false;
            elements.stopButton.disabled = true;
        }
        
        // Show error message
        function showError(message) {
            elements.status.textContent = message;
            elements.status.style.color = '#FF3B30';
            
            setTimeout(() => {
                elements.status.style.color = '';
                elements.status.textContent = 'Ready';
            }, 3000);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
